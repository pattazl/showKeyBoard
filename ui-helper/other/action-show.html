<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIV Animation</title>
    <style>
        .color-changing-div {
            position: relative;
            border: 1px blue solid;
            animation: colorShift 18s infinite linear;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        @keyframes colorShift {
            0% {
                background-color: #00B7EB;
            }

            16.67% {
                background-color: #C8D7E3;
            }

            33.33% {
                background-color: #7AC142;
            }

            50% {
                background-color: #003366;
            }

            66.67% {
                background-color: #0078D7;
            }

            83.33% {
                background-color: #8E44AD;
            }

            100% {
                background-color: #00B7EB;
            }
        }

        .allContain {
            width: calc(100% - 6px);
            margin: 0px;
            padding: 2px;
            border: 1px solid #ccc;
            position: relative;
        }

        .container,
        .new-div,
        .ctrl-div,
        .app-div {
            position: absolute;
            text-align: center;
        }
    </style>
</head>

<body>
    <div style="background-color: aliceblue;border: 1px red solid;">
        ‰ΩçÁΩÆÊòæÁ§∫
        <div class="allContain" id="mainContain"></div>
    </div>
</body>
<script>
    let monitorInfo = [{ "Left": -2880, "Top": 0, "Right": -1440, "Bottom": 900 }, { "Left": 0, "Top": 0, "Right": 2560, "Bottom": 1440 }]
    let newMonitor = [] // ËΩ¨Êç¢ÂêéÁöÑÁõëËßÜÂô®‰ø°ÊÅØ
    // ÂàõÂª∫‰∏Ä‰∏™Á™óÂè£ÊòæÁ§∫ Div
    let winOpt = {
        guiWidth: 240,
        guiHeigth: 0,
        guiBgcolor: "8611AA",
        guiBgTrans: 0,
        guiTrans: 1,
        guiOpacity: 38,
        guiTextFont: "Verdana",
        guiTextSize: 26,
        guiTextWeight: "bold",
        guiTextColor: "FFEE00",
        guiLife: 7000,
        guiInterval: 1000,
        guiPos: "TL",
        guiPosXY: "Y",
        guiPosOffsetX: 50,
        guiPosOffsetY: 50,
        guiDpiscale: 0,
        guiMonitorNum: 2, // Á¨¨Âá†‰∏™ÊòæÁ§∫Âô®
        guiMargin: 5,
        guiEdge: 1,
        txtSplit: " ",
        ctrlX: 500,
        ctrlY: 50,
        activeAppShowX: 600,
        activeAppShowY: 0,
        // Â§ßÂºÄÂÖ≥
        needShowKey: 1, // ÊòØÂê¶ÊòæÁ§∫ÊåâÈîÆ
        activeAppShow: 1, // ÊòØÂê¶ÊòæÁ§∫ËøõÁ®ãÂêç
        ctrlState: 1,  // ÊòØÂê¶ÊòæÁ§∫ÊéßÂà∂ÈîÆ

        ctrlWidth: 240,
        ctrlBgcolor: "11AA99",
        ctrlOpacity: 150,
        ctrlTextFont: "Verdana",
        ctrlTextSize: 20,
        ctrlTextWeight: "bold",
        ctrlTextColor: "FF0000",
    }
    let globalScale = 1;
    let globalSmallScale = 1;
    let globalMonitor = 1
    let timeOutList = [] // ‰∫ßÁîüÊñ∞textÁöÑÂÆöÊó∂Âô®Âè•ÊüÑ
    let ctrlAppSec = 12000  // ctrl Âíå appÁöÑÊòæÁ§∫Êó∂Èó¥

    function clearTimeout() {
        timeOutList.forEach(x => {
            clearInterval(x)
        })
        timeOutList = []
    }

    // Ê†πÊçÆ ÂÆΩÂ∫¶Âíå‰ΩçÁΩÆÁ°ÆÂÆöÂàùÂßã‰ΩçÁΩÆ
    function getInitPos(editHeight) {
        // ÊñπÂêëÊ†πÊçÆ guiPos Âíå guiPosXY ÂÜ≥ÂÆö guiPosOffsetX: 0, guiPosOffsetY: -50,
        // ÈªòËÆ§ TL
        let guiX = winOpt.guiPosOffsetX
        let guiY = winOpt.guiPosOffsetY

        let width = newMonitor[globalMonitor - 1].Width
        let height = newMonitor[globalMonitor - 1].Height
        // Ê≠§Â§ÑÂùêÊ†áÈúÄË¶ÅËΩ¨Êç¢‰∏∫‰∏çÂêåÂ±èÂπïÁöÑÔºåÊØè‰∏™Â±èÂπïÈªòËÆ§Ëµ∑ÂßãÁÇπ‰∏∫ 0 0
        switch (winOpt.guiPos) {
            case 'TR':
                guiX = guiX + width - winOpt.guiWidth
                break;
            case 'BL':
                guiY = guiY + height - editHeight
                break;
            case 'BR':
                guiX = guiX + width - winOpt.guiWidth
                guiY = guiY + height - editHeight
                break;
        }
        return { guiX, guiY }
    }
    // Ê†πÊçÆÂèÇÊï∞Ëé∑ÂèñÁßªÂä®ÊñπÂêë
    function getDirection() {
        switch (winOpt.guiPosXY) {
            // ‰∏ä‰∏ã
            case 'Y':
                if (winOpt.guiPos.indexOf('T') > -1) {
                    // Âêë‰∏ã
                    direction = 'down'
                } else {
                    // Âêë‰∏ä
                    direction = 'up'
                }
                break;
            case 'X':
                if (winOpt.guiPos.indexOf('L') > -1) {
                    // ÂêëÂè≥
                    direction = 'right'
                } else {
                    // ÂêëÂ∑¶
                    direction = 'left'
                }
                break;
        }
        return direction
    }
    function createAnimatedDivs() {
        // ÂàõÂª∫ÂâçÂÖàÊ∏ÖÁ©∫DIV
        clearDivs(objContainer)
        clearTimeout() // Ê∏ÖÁêÜÂÆöÊó∂Âô®
        if (winOpt.needShowKey == 1) {
            showKey()
        }
        if (winOpt.ctrlState == 1) {
            showCtrl()
        }
        if (winOpt.activeAppShow == 1) {
            showApp()
        }
    }
    function showCtrl() {
        let textArr = ['Caps', '^ Caps', '‚äû ‚éá', '^ ‚áß ‚éá', '^ ‚áß ‚äû ‚éá', '^ ‚áß ‚äû ‚éá Caps'];
        const newDiv = document.createElement('div');
        newDiv.classList.add('ctrl-div');
        let scale = globalScale
        // ÈúÄË¶ÅÊ†πÊçÆÂèÇÊï∞ÂàõÂª∫ guiWidth: 240, guiHeigth: 0, guiBgcolor: "8611AA", guiBgTrans: 0, guiTrans: 1, guiOpacity: 38, guiTextFont: "Verdana", guiTextSize: 26, guiTextWeight: "bold", guiTextColor: "FFEE00",
        newDiv.textContent = '';
        newDiv.style.width = winOpt.ctrlWidth * scale + 'px';
        newDiv.style.fontSize = winOpt.ctrlTextSize * scale + 'px';
        newDiv.style.fontFamily = winOpt.ctrlTextFont
        newDiv.style.backgroundColor = '#' + winOpt.ctrlBgcolor
        newDiv.style.opacity = winOpt.ctrlOpacity / 255
        newDiv.style.lineHeight = winOpt.ctrlTextSize * scale + 'px';
        newDiv.style.fontWeight = winOpt.ctrlTextWeight
        newDiv.style.color = '#' + winOpt.ctrlTextColor

        newDiv.style.top = winOpt.ctrlY * scale + 'px'
        newDiv.style.left = winOpt.ctrlX * scale + 'px'
        objContainer.appendChild(newDiv);
        // 3sÂêéÊ∏ÖÁêÜÊéâ
        textArr.forEach((text, i) => {
            // Èó¥ÈöîÂ§öÂ∞ëÁßí‰∫ßÁîüÊñ∞ÁöÑ
            let handle = setTimeout(() => {
                newDiv.textContent = text
            }, 1000 * i);
            timeOutList.push(handle)
        })
        let h = setTimeout(() => {
            try { objContainer.removeChild(newDiv); } catch (e) { }
        }, ctrlAppSec);
        timeOutList.push(h)
    }
    function showApp() {
        let textArr = ['SysDefault', 'Desktop','C:\\Windows\\explorer.exe', 'C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe']
        const newDiv = document.createElement('div');
        newDiv.classList.add('app-div');
        let scale = globalScale
        let fontSize = 12
        // ÈúÄË¶ÅÊ†πÊçÆÂèÇÊï∞ÂàõÂª∫ guiWidth: 240, guiHeigth: 0, guiBgcolor: "8611AA", guiBgTrans: 0, guiTrans: 1, guiOpacity: 38, guiTextFont: "Verdana", guiTextSize: 26, guiTextWeight: "bold", guiTextColor: "FFEE00",
        newDiv.textContent = '';
        newDiv.style.fontSize = fontSize * scale + 'px'; // ÈªòËÆ§12Âè∑Â≠ó‰Ωì
        newDiv.style.backgroundColor = '#F5F5F5'
        newDiv.style.lineHeight = fontSize * scale + 'px';

        newDiv.style.top = winOpt.activeAppShowY * scale + 'px'
        newDiv.style.left = winOpt.activeAppShowX * scale + 'px'
        objContainer.appendChild(newDiv);
        // 3sÂêéÊ∏ÖÁêÜÊéâ
        textArr.forEach((text, i) => {
            // Èó¥ÈöîÂ§öÂ∞ëÁßí‰∫ßÁîüÊñ∞ÁöÑ
            let handle = setTimeout(() => {
                newDiv.textContent = text
            }, 1000 * i);
            timeOutList.push(handle)
        })
        let h = setTimeout(() => {
            try { objContainer.removeChild(newDiv); } catch (e) { }
        }, ctrlAppSec);
        timeOutList.push(h)
    }
    function showKey() {
        let textArr = ['k e y', 'p r e s√ó2', 't e s t', 'üñ±Ô∏è√ó3 ^+v', '‚áß+c ‚ê£√ó12', '‚äû+d', 'Caps', 'Del√ó4'];
        textArr = textArr.map(x => {
            return x.replace(/ /g, winOpt.txtSplit);
        })
        textArr.forEach((text, i) => {
            // Èó¥ÈöîÂ§öÂ∞ëÁßí‰∫ßÁîüÊñ∞ÁöÑ
            let handle = setTimeout(() => {
                createNewTxt(text, globalScale)
            }, winOpt.guiInterval * i);
            timeOutList.push(handle)
        })
    }
    function createNewTxt(text, scale) {
        const newDiv = document.createElement('div');
        newDiv.classList.add('new-div');
        // ÈúÄË¶ÅÊ†πÊçÆÂèÇÊï∞ÂàõÂª∫ guiWidth: 240, guiHeigth: 0, guiBgcolor: "8611AA", guiBgTrans: 0, guiTrans: 1, guiOpacity: 38, guiTextFont: "Verdana", guiTextSize: 26, guiTextWeight: "bold", guiTextColor: "FFEE00",
        newDiv.textContent = text;
        if(winOpt.guiEdge == 1){
            newDiv.style.border = '1px solid'
        }
        newDiv.style.width = winOpt.guiWidth * scale + 'px';
        newDiv.style.fontSize = winOpt.guiTextSize * scale + 'px';
        newDiv.style.fontFamily = winOpt.guiTextFont
        let editHeight = winOpt.guiTextSize
        if (winOpt.guiHeigth != 0) {
            newDiv.style.height = winOpt.guiHeigth * scale + 'px';
            editHeight = winOpt.guiHeigth
        }
        editHeight *= scale
        console.log(editHeight)
        newDiv.style.backgroundColor = '#' + winOpt.guiBgcolor
        newDiv.style.opacity = winOpt.guiOpacity / 255

        newDiv.style.lineHeight = winOpt.guiTextSize * scale + 'px';
        newDiv.style.fontWeight = winOpt.guiTextWeight
        newDiv.style.color = '#' + winOpt.guiTextColor

        let { guiX, guiY } = getInitPos(editHeight)
        newDiv.style.top = guiY * scale + 'px'
        newDiv.style.left = guiX * scale + 'px'
        objContainer.appendChild(newDiv);
        const existingDivs = objContainer.querySelectorAll('.new-div');
        existingDivs.forEach(div => {
            if (div !== newDiv) {
                let direction = getDirection()
                let prePos = 0, selfSize = 0, offset = winOpt.guiMargin;
                switch (direction) {
                    case 'up':
                        prePos = parseInt(getComputedStyle(div).top) || 0;
                        selfSize = parseInt(getComputedStyle(div).height)
                        div.style.top = (prePos - offset - selfSize) + 'px';
                        break;
                    case 'down':
                        prePos = parseInt(getComputedStyle(div).top) || 0;
                        selfSize = parseInt(getComputedStyle(div).height)
                        div.style.top = (prePos + offset + selfSize) + 'px';
                        break;
                    case 'left':
                        prePos = parseInt(getComputedStyle(div).left) || 0;
                        selfSize = parseInt(getComputedStyle(div).width)
                        div.style.left = (prePos - offset - selfSize) + 'px';
                        break;
                    case 'right':
                        prePos = parseInt(getComputedStyle(div).left) || 0;
                        selfSize = parseInt(getComputedStyle(div).width)
                        div.style.left = (prePos + offset + selfSize) + 'px';
                        break;
                }
            }
        });
        // Ë∂ÖÊó∂ÂêéÊ∏ÖÁêÜÊéâ
        setTimeout(() => {
            try { objContainer.removeChild(newDiv); } catch (e) { }
        }, winOpt.guiLife);
    }
    // Ë¶ÅÂèñÊúÄÂ§ßËåÉÂõ¥ÔºåËΩ¨Êç¢ monitorInfo ÁöÑË¥üÊï∞‰ΩçÁΩÆ
    function getOffset(demoWidth) {
        let maxInfo = { "Left": 0, "Top": 0, "Right": 0, "Bottom": 0 }  // ÊúÄÂ∞èÁöÑ Left Top ÔºåÊúÄÂ§ßÁöÑ Right Bottom
        monitorInfo.forEach(x => {
            maxInfo.Left = Math.min(x.Left, maxInfo.Left)
            maxInfo.Top = Math.min(x.Top, maxInfo.Top)
            maxInfo.Right = Math.max(x.Right, maxInfo.Right)
            maxInfo.Bottom = Math.max(x.Bottom, maxInfo.Bottom)
        })
        // ÂùêÊ†áÂÖ®ÈÉ®ÂèòÊàêÊ≠£Êï∞
        let offsetX = 0, offsetY = 0
        if (maxInfo.Left < 0) {
            offsetX = - maxInfo.Left
        }
        if (maxInfo.Right < 0) {
            offsetY = - maxInfo.Right
        }
        let scale = demoWidth / (maxInfo.Right - maxInfo.Left)
        console.log('scale', maxInfo.Bottom - maxInfo.Top)
        let height = parseInt(scale * (maxInfo.Bottom - maxInfo.Top))
        // ÈúÄË¶ÅÊ†πÊçÆÊúÄÂ§ßÊúÄÂ∞èËÆ°ÁÆóÁº©ÊîæÊØîÔºåÊ†πÊçÆÂÆΩÂ∫¶ËÆ°ÁÆóÁº©ÊîæÊØîÔºådemoWidth
        return { offsetX, offsetY, scale, height }
    }
    function findDivs(parent) {
        const result = [];
        const allDivs = parent.querySelectorAll('div');
        return allDivs.length > 0;
    }
    function clearDivs(parent) {
        const childDivs = parent.querySelectorAll('div');
        childDivs.forEach(div => {
            div.remove();
        });
    }
    // getNewInfo()
    function initContain() {
        let main = document.getElementById("mainContain")
        // Ëé∑ÂèñÂÆΩÂ∫¶
        let { offsetX, offsetY, scale, height } = getOffset(parseInt(getComputedStyle(main).width))
        // ËÆ°ÁÆóÂÅèÁßªÔºå‰øÆÊîπ‰∏∫ Width Êàñ Height
        newMonitor = monitorInfo.map(x => {
            return { "Left": x.Left + offsetX, "Top": x.Top + offsetY, "Width": x.Right - x.Left, "Height": x.Bottom - x.Top }
        })
        console.log('newMonitor:', JSON.stringify(newMonitor))

        main.style.height = height + 'px'
        let arrHTML = newMonitor.map((x, i) => {
            let screenHTML = `<div style="top:${x.Top * scale}px;left:${x.Left * scale}px;" class="container">
            <div id="monitorId${i + 1}" style="width:${x.Width * scale}px;height:${x.Height * scale}px;" class="color-changing-div">
                <button onclick="fullScreen(${i + 1})">ÂÖ®Â±è${i + 1}</button>
            </div>
        </div>`
            return screenHTML
        })
        main.innerHTML = arrHTML.join('')
        // ÂºÄÂßãËßÇÂØü myDiv ÂÖÉÁ¥†
        newMonitor.map((x, i) => {
            let myDiv = document.getElementById(`monitorId${i + 1}`)
            observer.observe(myDiv);
        })
        globalSmallScale = scale
        globalScale = scale
        let monitorIndex = winOpt.guiMonitorNum
        if (monitorIndex > newMonitor.length || monitorIndex == 0) {
            monitorIndex = 1
        }
        globalMonitor = monitorIndex
    }
    // ÂÖ®Â±è‰ª£Á†Å
    function fullScreen(id) {
        const myDiv = document.getElementById('monitorId' + id);
        toggleFullscreen(myDiv)
    }

    function toggleFullscreen(myDiv) {
        if (document.fullscreenElement) {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        } else {
            if (myDiv.requestFullscreen) {
                myDiv.requestFullscreen();
            } else if (myDiv.webkitRequestFullscreen) {
                myDiv.webkitRequestFullscreen();
            } else if (myDiv.mozRequestFullScreen) {
                myDiv.mozRequestFullScreen();
            } else if (myDiv.msRequestFullscreen) {
                myDiv.msRequestFullscreen();
            }

        }
    }
    document.addEventListener('fullscreenchange', function () {
        console.log('fullscreenchange', document.fullscreenElement)
        if (document.fullscreenElement == null) {
            globalScale = globalSmallScale // ÈÄÄÂõûÊôÆÈÄöÁä∂ÊÄÅ
            createAnimatedDivs()
        } else {
            if (document.fullscreenElement == objContainer) {
                globalScale = 1
                createAnimatedDivs()
            }
        }
    });

    document.addEventListener('fullscreenerror', function () {
        console.error('ÂÖ®Â±èÊìç‰ΩúÂá∫Èîô');
    });
    // ÁõëÊéßÂèòÂåñ
    const observer = new ResizeObserver(entries => {
        // for (const entry of entries) {
        //     const { width, height } = entry.contentRect;
        //     // ÈúÄË¶ÅÈáçÊñ∞ÊºîÁ§∫Âä®Áîª
        //     console.log(entry.target, objContainer)
        //     if (entry.target == objContainer) {
        //         createAnimatedDivs()
        //         console.log('createAnimatedDivs2222')
        //     }
        // }
    });
    // ÂàùÂßãÂåñÂÆπÂô®
    initContain()
    let objContainer = document.getElementById('monitorId' + globalMonitor); // ÂÆπÂô®ÊòæÁ§∫
    // Ë∞ÉÁî®ÂáΩÊï∞Ôºå‰º†ÂÖ•ÂÆπÂô® ID ÂíåÁßªÂä®ÊñπÂêë
    //createAnimatedDivs();
    setInterval(() => { if (!findDivs(objContainer)) { createAnimatedDivs(); } }, 1000)
</script>

</html>